#### 快速排序

C 语言中自带函数库中就有快速排序——qsort 函数，包含在<stdlib.h> 头文件中。

快速排序算法是在起泡排序的基础上进行改进的一种算法，其实现的基本思想是：通过一次排序将整个无序表分成相互独立的两部分，其中一部分中的数据都比另一部分中包含的数据的值小，然后继续沿用此方法分别对两部分进行同样的操作，直到每一个小部分不可再分，所得到的整个序列就成为了有序序列。

例如，对无序表 `{49，38，65，97，76，13，27，49}` 进行快速排序，大致过程为：

1. 首先从表中选取一个记录的关键字作为分割点（称为 *枢轴* 或者 *支点* ，一般选择第一个关键字），例如选取49；
2. 将表格中大于49 个放置于49 的右侧，小于49 的放置于49 的左侧，假设完成后的无序表为： `{27，38，13，49，65，97，76，49}` ；
3. 以49 为支点，将整个无序表分割成了两个部分，分别为 `{27，38，13}` 和 `{65，97，76，49}` ，继续采用此种方法分别对两个子表进行排序；
4. 前部分子表以27 为支点，排序后的子表为 `{13，27，38}` ，此部分已经有序；后部分子表以65 为支点，排序后的子表为 `{49，65，97，76}` ；
5. 此时前半部分子表中的数据已完成排序；后部分子表继续以65 为支点，将其分割为 `{49}` 和 `{97，76}` ，前者不需排序，后
者排序后的结果为 `{76，97}` ；
6. 通过以上几步的排序，最后由子表 `{13，27，38}` 、 `{49}`、`{49}`、`{65}`、`{76，97}` 构成有序表： `{13，27，38，49，49，65，76，97}` ；

整个过程中最重要的是实现第2 步的分割操作。

- 设置两个指针 low 和 high , 分别指向无序表的表头和表尾。
- 先由 high 指针从右向左依次遍历， 直到找到一个比 49 小的关键字，然后进行互换。
- 然后指针 low 从左向右依次遍历，直到找到一个比 49 大的关键字，然后进行互换。
- 然后重复上述步骤，直到两个指针相遇，整个过程结束。

快速排序算法的时间复杂度为 `O(nlogn)` ，是所有时间复杂度相同的排序方法中性能最好的排序算法。